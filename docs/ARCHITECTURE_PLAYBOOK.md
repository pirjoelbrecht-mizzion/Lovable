# Multi-Session Training Architecture Playbook

## Overview

This playbook documents the multi-session adaptive training system architecture. It's your reference guide for understanding, maintaining, and extending the system safely.

**Key Principle:** The system is locked in by tests (STEP 9), invariants (STEP 10), and telemetry (STEP 11). Regressions are architecturally impossible, but understanding the rules is essential for safe development.

---

## Table of Contents

1. [Core Concepts](#core-concepts)
2. [Session Model](#session-model)
3. [How to Add a New Session Type](#how-to-add-a-new-session-type)
4. [Where NOT to Add Logic](#where-not-to-add-logic)
5. [Forbidden Patterns](#forbidden-patterns)
6. [Debugging Regressions](#debugging-regressions)
7. [Safety Guards](#safety-guards)

---

## Core Concepts

### Sessions vs Days

- **Days** are containers only (a specific date with multiple sessions)
- **Sessions** are atomic units of training (run, strength, core, heat, altitude, mobility)
- A day can have 0, 1, 2, or more sessions
- Days have NO type; only sessions have types

### Session Identity

- Each session has a unique `id` (string)
- Session identity is STABLE across all operations
- Select sessions by ID: `sessions.find(s => s.id === targetId)`
- Never select by position: `sessions[0]` ❌
- Never infer by title: `title.includes('Run')` ❌

### Session Origin (Ownership)

Sessions are owned by their origin:

- `BASE_PLAN` - From coach/template (protected, cannot be deleted)
- `USER` - User manually added (protected, cannot be deleted)
- `ADAPTIVE` - Generated by adaptive engine (can be deleted/modified)
- `STRENGTH`, `HEAT`, `ALTITUDE`, `CORE` - Feature-specific sessions
- `RACE` - Race day sessions (protected, never removed)

**Critical Rule:** Only sessions with origin `ADAPTIVE` can be deleted. BASE_PLAN and USER sessions can only be modified.

### Session Locking

Sessions can be locked (`locked: true`) with a reason (`lockReason`):

- Locked sessions cannot be removed under any circumstances
- Locked sessions can still be modified (intensity, duration, etc.)
- BASE_PLAN sessions are typically locked

---

## Session Model

### TrainingSession Interface

```typescript
interface TrainingSession {
  id: string;                          // Unique identifier
  type: SessionType;                   // RUN, STRENGTH, CORE, HEAT, ALTITUDE, MOBILITY
  role: SessionRole;                   // AEROBIC_DEVELOPMENT, MUSCULAR_ENDURANCE, etc.
  priority: SessionPriority;           // PRIMARY, SUPPORT, SECONDARY

  origin: SessionOrigin;               // BASE_PLAN, USER, ADAPTIVE, etc.
  locked: boolean;                     // Cannot be removed if true
  lockReason?: LockReason;             // Why is it locked?

  loadProfile: LoadProfile;            // Multi-dimensional load (cardiovascular, muscular, etc.)
  prescription: Record<string, any>;   // Type-specific prescription

  title?: string;                      // Display title
  description?: string;                // Human-readable description
  notes?: string;                      // Additional notes
  completed?: boolean;                 // Has this session been completed?
}
```

### TrainingDay Interface

```typescript
interface TrainingDay {
  date: string;                        // YYYY-MM-DD
  sessions: TrainingSession[];         // Multiple sessions per day OK

  totalLoad?: LoadProfile;             // Computed: aggregate of session loads
  totalDuration?: number;              // Computed: sum of session durations
  totalDistance?: number;              // Computed: sum of session distances
}
```

---

## How to Add a New Session Type

### Step 1: Define the Type

Add to `src/types/training.ts`:

```typescript
export type SessionType =
  | 'RUN'
  | 'STRENGTH'
  | 'CORE'
  | 'HEAT'
  | 'ALTITUDE'
  | 'MOBILITY'
  | 'YOUR_NEW_TYPE';  // ← Add here
```

### Step 2: Define the Role

Add to `src/types/training.ts`:

```typescript
export type SessionRole =
  | 'AEROBIC_DEVELOPMENT'
  | 'MUSCULAR_ENDURANCE'
  | 'THERMOREGULATION'
  | 'RECOVERY_SUPPORT'
  | 'YOUR_NEW_ROLE';  // ← Add here
```

### Step 3: Create a Module for Your Session Type

Create: `src/components/your-feature/YourSessionTypeModule.tsx`

This module should:
- ✅ Accept session ID as a prop
- ✅ Find the session by ID
- ✅ Check that session.type matches expected type
- ✅ Render UI specific to this session type

Example:

```typescript
interface YourSessionTypeModuleProps {
  sessionId: string;
  day: TrainingDay;
}

export function YourSessionTypeModule({ sessionId, day }: YourSessionTypeModuleProps) {
  const session = day.sessions.find(s => s.id === sessionId);

  if (!session || session.type !== 'YOUR_NEW_TYPE') {
    return null;  // Not our session
  }

  // Render module-specific UI
  return <div>...</div>;
}
```

### Step 4: Add Soft Guard Check

In your module, add a soft guard to detect misrouted sessions:

```typescript
import { guardSessionType } from '@/lib/architecture/softGuards';

export function YourSessionTypeModule({ sessionId, day }: YourSessionTypeModuleProps) {
  const session = day.sessions.find(s => s.id === sessionId);

  guardSessionType(sessionId, 'YOUR_NEW_TYPE', session?.type, 'YourSessionTypeModule');

  if (!session || session.type !== 'YOUR_NEW_TYPE') {
    return null;
  }

  // ...
}
```

### Step 5: Create a Test

Create: `src/tests/yourSessionType.test.ts`

Test that:
- ✅ Sessions of your type are only accessed by your module
- ✅ Sessions of other types never reach your module
- ✅ Session ID is used for selection, not type inference

---

## Where NOT to Add Logic

### ❌ DON'T: Add logic based on title parsing

```typescript
// WRONG
if (session.title.includes('Strength')) {
  // ... handle as strength
}
```

**Why?** Titles are display-only and can be customized by users. Use `session.type` instead.

### ❌ DON'T: Merge sessions on the same day

```typescript
// WRONG
if (day.sessions.length > 1) {
  combineIntoSingleSession(day.sessions);
}
```

**Why?** Multi-session days are first-class citizens. Each session is atomic.

### ❌ DON'T: Delete sessions based on type inference

```typescript
// WRONG
const toDelete = day.sessions.filter(s => s.title.includes('Recovery'));
day.sessions = day.sessions.filter(s => !toDelete.includes(s));
```

**Why?** Only ADAPTIVE sessions can be deleted, and only by origin check, not type inference.

### ❌ DON'T: Access sessions by position

```typescript
// WRONG
const runSession = day.sessions[0];  // Wrong if first session is strength
```

**Why?** Sessions can be in any order. Use ID-based lookup.

### ❌ DON'T: Infer session type from day properties

```typescript
// WRONG
if (day.isHardDay) {
  // Assume all sessions are intensity
}
```

**Why?** Each session has its own type and role. Days are containers only.

---

## Forbidden Patterns

These patterns are detected by STEP 9 tests and STEP 10 invariants:

### Pattern 1: Session ID Collisions

```typescript
// FORBIDDEN
const newSession = { ...oldSession, id: oldSession.id };  // Duplicate ID
```

**Detection:** `assertUniqueSessionIds` in STEP 9 tests

### Pattern 2: Missing Session IDs

```typescript
// FORBIDDEN
const session = { type: 'RUN', title: '...' };  // No ID
day.sessions.push(session);
```

**Detection:** `assertSessionHasId` in STEP 9 tests

### Pattern 3: Non-Strength Sessions in Strength Module

```typescript
// FORBIDDEN
// In StrengthTraining component:
const sessions = day.sessions;  // Include RUN sessions
sessions.forEach(renderStrengthUI);  // But run sessions appear in strength module
```

**Detection:** `assertSessionNotInWrongModule` in STEP 9 tests

### Pattern 4: Deleting BASE_PLAN/USER Sessions

```typescript
// FORBIDDEN
if (session.origin === 'BASE_PLAN') {
  day.sessions = day.sessions.filter(s => s !== session);  // NOPE
}
```

**Detection:** `assertOwnershipProtection` in STEP 9 tests

### Pattern 5: Session Type Mismatch in Adaptation

```typescript
// FORBIDDEN
// Adaptive controller creates a run session but marks it as STRENGTH
const session = {
  type: 'STRENGTH',  // But prescription is for running
  prescription: { distanceKm: 10, pace: 'tempo' }
};
```

**Detection:** Checked in conflict resolution + soft guards

---

## Debugging Regressions

### If You See This Error

```
[ARCHITECTURE VIOLATION] Session missing id in YourComponent.weekPlan
```

**What it means:** A session doesn't have an ID
**How to fix:** Ensure all sessions created have unique IDs

```typescript
const newSession = {
  id: generateSessionId(),  // ← Always include
  type: 'RUN',
  // ...
};
```

### If You See This Error

```
[ARCHITECTURE VIOLATION] Duplicate session IDs detected in Quest.sessions
```

**What it means:** Two sessions have the same ID
**How to fix:** Use the `id` field from the session, not a generated one

```typescript
// WRONG
const sessionId = `${session.type}-${day.date}`;  // Not unique if duplicates exist

// RIGHT
const sessionId = session.id;  // Use the session's own ID
```

### If You See This Error

```
[ARCHITECTURE VIOLATION] Non-strength session reached Strength module
```

**What it means:** A RUN, CORE, HEAT, or other non-STRENGTH session appeared in StrengthTraining component
**How to fix:** Filter sessions before passing to module

```typescript
const strengthSessions = day.sessions.filter(s => s.type === 'STRENGTH');
return <StrengthTrainingModule sessions={strengthSessions} />;
```

### If Telemetry Shows "Session count warning"

```
[Telemetry] Session count warning { count: 7, limit: 6 }
```

**What it means:** A day has more than 6 sessions (soft cap exceeded)
**What to do:** Investigate if:
- User accidentally added duplicate sessions
- Adaptive engine is creating too many compensation sessions
- UI is having trouble rendering so many sessions

**Don't block it**, but monitor and log.

---

## Safety Guards

The system uses three layers of safety:

### Layer 1: STEP 9 Tests (Development)

- 52 tests validate architectural rules
- Run during `npm run build`
- Catches violations before deployment

### Layer 2: STEP 10 Invariants (Development)

- Assertions throw in dev mode
- Catches subtle regressions during development
- Zero overhead in production (all assertions disabled)

### Layer 3: STEP 11 Telemetry & Soft Guards (Production)

- Log issues without crashing
- `warnIf()` checks conditions in production
- `logSessionCountWarning()` alerts to unusual configs
- Never blocks rendering or user experience

### Using Soft Guards

```typescript
import { guardSessionType, warnIf } from '@/lib/architecture/softGuards';

function MyComponent({ sessionId, day }: Props) {
  const session = day.sessions.find(s => s.id === sessionId);

  // Guard 1: Check type
  guardSessionType(sessionId, 'RUN', session?.type, 'MyComponent');

  // Guard 2: Conditional warning
  warnIf(
    !session?.title,
    'Session missing title in MyComponent',
    { sessionId }
  );

  if (!session || session.type !== 'RUN') {
    return null;  // Still render nothing if wrong type
  }

  return <div>...</div>;
}
```

---

## Key Files

- `src/types/training.ts` - Core data types (TrainingSession, TrainingDay, TrainingWeek)
- `src/lib/telemetry/trainingTelemetry.ts` - Observability/logging
- `src/lib/architecture/softGuards.ts` - Production-safe validators
- `src/tests/sessionSelection.test.ts` - Session ID selection tests
- `src/tests/ownershipProtection.test.ts` - Origin protection tests
- `src/tests/strengthIsolation.test.ts` - Module isolation tests
- `src/tests/migrationSnapshot.test.ts` - Data durability tests

---

## Quick Checklist: Before You Commit

- ✅ All sessions have unique IDs
- ✅ Session selection uses ID, not position or title
- ✅ Session type is checked before using session data
- ✅ Deleted sessions have origin === 'ADAPTIVE'
- ✅ New modules filter sessions by type
- ✅ Soft guards added to new modules
- ✅ No title-based logic
- ✅ No day-level inferences
- ✅ No session merging
- ✅ Tests pass (`npm run build`)

---

## Questions?

Refer to the architecture tests or telemetry logs. They document expected behavior through concrete examples.

**Last Updated:** STEP 11 (December 2025)
